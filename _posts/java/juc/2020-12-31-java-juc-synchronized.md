---
layout: post
title:  "java多线程--synchronized"
date:   2020-12-31
categories: java
tag: juc
---

* content
{:toc}
# Synchronized关键字 #

## 概念

- synchronized 是为了解决多线程同步访问资源的问题。 synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
- Java多线程依赖于操作系统原生线程，所以挂起或者唤醒一个线程，需要操作系统帮忙完成。而操作系统需用从用户状态切换成内核状态，时间相对较长，时间成本高。

## 使用

- 修改实例方法和代码块：作用于给当前对象加锁
- 修饰静态方法和代码块：作用于给当前类加锁

## synchronized底层原理

**synchronized 关键字底层原理是JVM层面的**

- synchronized 同步语句块的情况
  1. synchronized 同步语句块的实现使用的是 monitorenter 和 monitoreexit 指令， 期中 monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置
  2. 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor 对象的特有权。当计数器为 0 则可以成功获取，获取后将锁计数器设为 1 就就是 加1 。相对应的在执行 monitorexit 指令后， 所得计数器就会 -1，当锁计数器变为0，标明锁被释放。
  3. 如果获取对象的锁失败，那么当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
  4. （monitor 对象存在于每个 java 对象的对象头中 ，synchronized 锁便是通过这种方式获取锁的，也是为什么java中任意对象可以作为锁的原因）

- synchronized 修饰方法的情况
  1. JVM 通过 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。
  2. 用的是一个隐式的 monitorenter 和 monitorexit 指令。

## synchronized 锁优化的过程（锁升级）

- 锁的状态有：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，随着锁竞争的激烈而逐渐升级。锁只可以升级不可以降级，这种策略是为了提高获取锁和释放锁的效率。

### 偏向锁

> 单个线程重复访问资源的时候没有必要向操作系统重新申请轻量级锁。

- 过程：
  1. 一个线程加锁的时候会在对象头添加标识（线程id）,以后这个线程进入或者退出代码块的时候不需要CAS的操作来加锁和解锁，只需要判断一个对象头（Mark Word）是否存储了执行当前线程的偏向锁。如果测试成功，表明当前线程已经获得了锁。如果失败，判断锁的标志位是否为1，为1，使用CAS竞争锁。不为1，就尝试将对象头的偏向锁指向当前线程。

- 偏向锁的撤销
  1. 偏向锁适用于任何

