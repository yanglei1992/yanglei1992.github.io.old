---
layout: post
title:  "redis主从复制"
date:   2020-12-13
categories: redis
tag: redis
---

* content
{:toc}

# Redis主从复制

## 概念

主从复制，是指将一台redis服务的数据，复制到其他的 redis 服务器。前者称为主节点（Master/Leader），后者称为从节点（Slave/Follower），数据的复制是单向的，只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。

默认情况下，每台 Redis 服务器都是主节点，一个主节点可以有 0 个或者多个从节点，但是每个从节点只能有一个主节点。

## 作用

1. 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。
2. 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式。
3. 负载均衡：在主从复制的基础上，配合读写分离，有主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的情境下，通过多个从节点分担负载，提供并发量。
4. 高可用基石：主从复制还是哨兵和集群能都实施的基础。

## 为什么使用集群

1. 单台服务器难以负载大量的请求
2. 单台服务器故障率高，系统崩坏概率大
3. 单台服务器内存容量有限

## 环境配置

我们在讲解配置文件的时候，注意到有一个 replication 模块（间 redis.conf 中第8条）

查看当前库的信息： info replication

// TODO

既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改一下信息：

- 端口号
- pid 文件名
- 日志文件名 
- rdb 文件名

启动单机多服务集群：

// TODO

### 一主二从配置

**默认情况下，每台 Redis 服务器都是主节点； 我们一般情况下只用配置从机就好了！**

使用 SALVEOF host port 就可以为从机配置主机了。

// TODO

然后主机上也能看到从机的状态

// TODO

我们这里使用命令搭建，是暂时的，真实开发中应该在从机配置文件中进行过配置，这样的话就是永久的。

// TODO

### 使用规则

1. 从机只读，不能写，主机可读可写但是多用于写。// TODO
2. 当主机断点宕机后，默认情况下从机的角色不会发生变化，集群中只是丢失了写操作，当主机恢复以后，又会连上从机恢复原状。
3. 当从机宕机后，若不是使用配置的配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若次吃重新配置称为从机，又可以获取到主机的所有数据。这里就是提到一个同步原理。
4. 第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：
   - ​	从机手动执行命令 slaveof  no  one，这样执行以后从机独立出来称为一个主机
   - 使用哨兵模式（自动选举）

> 如果没有老大了，这个时候能不能选择出来一个老大呢？手动？

如果主机断开了连接，我们可以使用 slaveof no one 让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大恢复了，那么就重新连接！

## 哨兵模式

主从切换技术的方法是：**当主机宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用**。这不是一种推荐的方式，更多的时候，我们优先考虑哨兵模式。

### 单机单个哨兵

- 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。
- 当哨兵检测到 master 宕机，会自动将 slave 切换成 master ， 然后通过 **发布订阅模式** 通知其他从服务器，修改配置文件，让它们切换成主机。

### 多哨兵模式

哨兵的核心配置

```shell
sentinel monitor mymaster 127.0.0.1 6379 1
```

- 数字1表示：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。

> 测试

```shell
redis-sentinel xxx/sentinel.conf
```

成功启动哨兵模式

// TOOD

此时哨兵模式监视着我们的主机6379，当我们断开主机后：

// TOOD

### 哨兵的优缺点

#### 优点

1. 哨兵集群，基于主从复制模式，所有的主从复制的有点，他都有
2. 主从可以切换，故障可以转移，系统的可用性好
3. 哨兵模式是主从模式的升级，手动到自动，更加健壮

#### 缺点

1. Redis 不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦
2. 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项

> 哨兵模式的全部配置

### 完整的哨兵模式配置文件 sentinel.conf

```bash
# Example sentinel.conf
 
# 哨兵sentinel实例运行的端口 默认26379
port 26379
 
# 哨兵sentinel的工作目录
dir /tmp
 
# 哨兵sentinel监控的redis主节点的 ip port 
# master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。
# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了
# sentinel monitor <master-name> <ip> <redis-port> <quorum>
sentinel monitor mymaster 127.0.0.1 6379 1
 
# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码
# sentinel auth-pass <master-name> <password>
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
 
 
# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒
# sentinel down-after-milliseconds <master-name> <milliseconds>
sentinel down-after-milliseconds mymaster 30000
 
# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，
这个数字越小，完成failover所需的时间就越长，
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。
可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。
# sentinel parallel-syncs <master-name> <numslaves>
sentinel parallel-syncs mymaster 1
 
 
 
# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： 
#1. 同一个sentinel对同一个master两次failover之间的间隔时间。
#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。
#3.当想要取消一个正在进行的failover所需要的时间。  
#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了
# 默认三分钟
# sentinel failover-timeout <master-name> <milliseconds>
sentinel failover-timeout mymaster 180000
 
# SCRIPTS EXECUTION
 
#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。
#对于脚本的运行结果有以下规则：
#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10
#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。
 
#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，
#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，
#一个是事件的类型，
#一个是事件的描述。
#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。
#通知脚本
# sentinel notification-script <master-name> <script-path>
  sentinel notification-script mymaster /var/redis/notify.sh
 
# 客户端重新配置主节点参数脚本
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。
# 以下参数将会在调用脚本时传给脚本:
# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>
# 目前<state>总是“failover”,
# <role>是“leader”或者“observer”中的一个。 
# 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的
# 这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentinel client-reconfig-script <master-name> <script-path>
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh
```

## redis 红锁（redlock）

关于分布式锁，一般有三种选择，

1. redis 
2. zk
3. DB锁（悲观锁、乐观锁）

 其中用的最多的应该是redis。

redis常用的方式有单节点、主从模式、哨兵模式、集群模式。

单节点在生产环境基本上不会使用，因为不能达到高可用，且连RDB或AOF备份都只能放在master上，所以基本上不会使用。

另外几种模式都无法避免两个问题：

1. 异步数据丢失。
2. 脑裂问题。

所以redis官方针对这种情况提出了红锁（**Redlock**）的概念。

假设有5个redis节点，这些节点之间既没有主从，也没有集群关系。客户端用相同的key和随机值在5个节点上请求锁，请求锁的超时时间应小于锁自动释放时间。当在3个（超过半数）redis上请求到锁的时候，才算是真正获取到了锁。如果没有获取到锁，则把部分已锁的redis释放掉。

 